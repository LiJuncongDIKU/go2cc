# 通讯协议
## 网络模型
| 层         | 典型协议 / 标准        | 描述                                                             |
| ---------- | ---------------------- | ---------------------------------------------------------------- |
| 应用层     | HTTP、WebSocket、MQTT  | 为应用程序提供网络服务与通信接口                                 |
| 传输层     | TCP、UDP               | 提供端到端进程间的逻辑通信                                       |
| 网络层     | IP                     | 提供主机到主机的路径选择与分组转发                               |
| 数据链路层 | Ethernet、WiFi         | 提供相邻节点之间的帧传输与差错控制                               |
| 物理层     | RJ45、以太网物理层标准 | 提供原始比特流的透明传输，比如有光无光或者高低电压信号代表“0”“1” |

## http/https 协议
直译是超文本传输协议，浏览器常用。\
总理解 https = http + 加密层（SSL/TLS）, 对于传输中的性能问题，比如头压缩、分块传输、并行请求等，实际上是http的发展，而https则是在http基础上添加了加密层，解决了数据传输中的安全问题。
#### http
| 🌐&emsp;&emsp;&emsp;&emsp; | HTTP 1.0 | HTTP 1.1                | HTTP 2.0                       |
| :------------------------ | :------- | :---------------------- | :----------------------------- |
| **连接模型**              | 短连接   | 长连接                  | 多路复用                       |
| **队头阻塞**              | 严重     | 存在 (应用层 FIFO 阻塞) | 解决应用层阻塞 (存在 TCP 阻塞) |
| **传输层协议**            | TCP      | TCP                     | TCP                            |
| **传输格式**              | 文本     | 文本                    | 二进制分帧 (Binary Frame)      |
| **安全性**                | 明文     | 明文 (支持 SSL/TLS)     | 强制要求 TLS 1.2+              |
| **服务端推送**            | 不支持   | 不支持                  | 支持 (Server Push)             |
| **默认端口**              | 80       | 80/ TLS 443             | 443                            |

我们基于上面的表再理解一下概念：
:::tip 链接问题 🔗
- http 1.0 短连接，早期网页非常简单，大多数情况下只有一个html文件，服务器发送完一次消息之后主动TCP挥手
- http 1.1 长连接，保持TCP连接不断，但是存在应用级阻塞-如果只有一个TCP链接，前面的请求没有结束，其他请求就会阻塞；浏览器会主动建立多个TCP连接，Chrome默认6个，Firefox默认8个。
- http 2.0 多路复用，多个请求并行在一个TCP连接上，基本上同一个域名只会有一个TCP连接，数据传输是分数据帧交叉进行。
:::

#### https
直译 **HTTP over TLS** (Transport Layer Security)，中文通常翻译为 “传输层安全性协议”
- HTTP 1.1 的流程：TCP 握手 -> 直接发送 HTTP Request -> HTTP Response
- HTTPS 的流程：TCP 握手 -> TLS 握手（交换密钥/证书） -> 加密后的 HTTP Request -> 加密后的 HTTP Response

:::warning TLS 1.3 加解密过程
- 服务器向 CA 申请证书，包含公钥，自己保留私钥
- 客户端验证证书合法性、有效期、签名
- 客户端生成临时密钥对（EC），发临时公钥
- 服务器生成临时密钥对（EC），发临时公钥
- 双方用 ECDHE 算出相同的会话密钥
- 服务器用私钥签名，证明身份
- 之后全部使用会话密钥对称加密
:::

## websocket 协议
在 WebSocket 出现之前，实现实时通信通常靠 轮询（Polling）：浏览器每隔几秒就向服务器发送请求
- 浪费带宽
- 延迟不是实时的，取决于轮询的时间间隔
- 相当于服务器频繁断开重连

#### websocket
- 基于 TCP 协议，ws: 80, wss: 443
- 握手阶段，浏览器发送 HTTP 请求，服务器返回 HTTP 响应，升级为 WebSocket 协议
- 之后，浏览器和服务器之间可以直接发送 WebSocket 帧

## MQTT 协议
MQTT 的全称是 Message Queuing Telemetry Transport（消息队列遥测传输协议）。
- 基于TCP，低功耗，报文精简。
- MQTT: 1883 明文，MQTT over TLS: 8883 加密
- 基于发布/订阅模式，结合服务等级介绍三个角色：
  - 发布者（Publisher）：发布消息到指定主题（Topic）
  - 订阅者（Subscriber）：订阅感兴趣的主题，接收发布者的消息
  - 代理（Broker）：负责消息的路由和存储，确保发布者和订阅者之间的通信

#### QoS 服务等级
- 等级 0
  1. 向代理发送消息
  2. 代理将消息路由到合适的订阅者
  3. 订阅者接收消息
  4. 不管B没收到还是S没收到，都认为消息发送成功
- 等级 1
  1. 向代理发送消息，等待确认，收到确认前可能重发
  2. 代理向发布者返回确认报文
  3. 代理将消息路由到合适的订阅者，收到确认前可能重发
  4. 订阅者接收消息，返回确认报文给代理
  5. 整个过程中，P和B的消息可能重发，确认报文也可能重发
- 等级 2
  1. 向代理发送消息，等待确认，收到确认前可能重发
  2. 代理向发布者返回确认报文
  3. 代理将消息路由到合适的订阅者，收到确认前可能重发
  4. 订阅者接收消息，返回确认报文给代理
  5. 整个过程中，P和B的消息可能重发，确认报文也可能重发
```
发布者（P）        代理（B）        订阅者（S）
   | PUBLISH (QoS0) | PUBLISH (QoS0) |
   |─────1msg──────>| ───── N ─────> |
   │                │                │
   │ PUBLISH (QoS1) │                │
   │───────1───────>│                │
   │ ------------>  │                │ 没收到确认可能重发
   │    确认报文    │                 │
   │ <─────1──────  │                │ P→B完成 
   │ <-----------   │                │ 可能收到多余的确认报文
   │                │ PUBLISH (QoS1) │ 
   │                │ ───── N ─────> │
   │                │ ------------>  │ 没收到确认可能重发
   │                │                │
   │                │ 确认报文        │
   │                │<───── N ───────│ S确认B→S完成
   │                │ <------------  │ 可能收到多余的确认报文
   │                │                │
```
上面是等级0和等级1的区别，我们发现等级1其实是两次独立的确认过程，P→B和B→S，称之为**两次握手**，而等级2是独立的两轮 **四次握手**。
- PUBLISH（消息本体）
- PUBREC（我收到了）
- PUBREL（你可以交付了）
- PUBCOMP（全部完成）
```text
发送者       接收者
│            │
│ PUBLISH    │
│───────────>│
│            │
│    PUBREC  │
│<───────────│ 这四条报文任意一条丢失都会重发其本身，而多余的确认报文会被忽略
│            │
│ PUBREL     │
│───────────>│
│            │
│    PUBCOMP │
│<───────────│
```

## 传输层：TCP
三次握手：
- 客户端发送 SYN 报文，请求连接
- 服务器收到 SYN 报文，回复 SYN-ACK 报文，确认连接
- 客户端收到 SYN-ACK 报文，回复 ACK 报文，确认连接
- 确保双方的收发报文正常

:::danger DDos攻击-SYN Flood
1. 攻击者伪造大量的 虚拟 IP 地址，向服务器发送成千上万个 SYN 报文。
2. 半连接状态：服务器以为是正常请求，于是回复了 SYN-ACK，并将这些连接放入 “半连接队列”（SYN Queue） 中，等待最后的 ACK。
3. 服务器会一直等不到最后的确认。
4. 这些半连接状态的连接会占用服务器的资源，导致服务器无法响应正常的请求。
:::

四次挥手：
- 客户端 → 服务端：FIN，我没数据要发了，请求关闭我的发送通道
- 服务端 → 客户端：ACK，收到你的关闭请求
- 服务端 → 客户端：FIN，我也没数据了，关闭我的发送通道
- 客户端 → 服务端：ACK，收到，连接彻底关闭

## 传输层：UDP
> UDP：快、简单、不可靠，适合实时性比可靠性更重要的场景。
- 不用三次握手，想发就发，直接打包发送
- 不保证一定到达，可能丢包
- 不保证顺序，可能乱序
- 没有拥塞控制，速度快、开销小
- 一对一、一对多、多对多都支持（支持广播、组播）
