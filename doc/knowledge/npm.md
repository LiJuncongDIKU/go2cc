
## npm
作为默认的包管理工具，所有前端开发者都离不开它。而它在发展中遇到的问题和解决策略也影响着当下流行的`yarn`和`pnpm`。
这里整理了一些关键的更新，或者与日常开发关系比较大的
1. :wheel: 生态空白，前端工程需要一个工具快速管理依赖 
2. 安装方式： 允许在`npm` 平台注册的，允许直接从 `git` 仓库安装依赖
3. 引入[语义化版本（SemVer）标准](https://semver.org/lang/zh-CN/)，项目和工具包都应该遵守
4. `npm 3+`：扁平化依赖树：
   1. 从前的npm直接嵌套依赖，每个包安装各自的依赖，除了浪费空间还会使得windows系统下的文件路径过长
   2. 将所有依赖平铺到 `node_modules` 目录下，当版本冲突时才会嵌套安装
5. `npm 5+`：引入了 `package-lock.json` 文件，记录了精确的依赖版本信息，避免了版本冲突问题。
   1. 很多开发者gitignore默认忽略了 `package-lock.json` 文件，其实我认为大多数项目不应该如此
   2. `package.json` 中配置的依赖是范围式的，初衷是为了方便 `npm update`, 但是前端业务项目中通常固定的版本可以避免很多潜在问题
   3. 新增了 `npm ci` 命令，用于安装 `package-lock.json` 中指定的版本，跳过解析
6. `npm 6+`：规避恶意依赖的问题，之前说过npm install会执行脚本导致被攻击，新增了 `npm audit` 命令，用于检查项目依赖是否存在安全漏洞
7. `npm 7+`：引入了 `workspaces` 字段，用于管理 [Monorepo](#monorepo) 项目中的多个子项目。

这时候时间已经来到2020年了，现代包管理工具应该具备的功能已经基本成型，此时npm面临的主要是速度问题，和安全问题。

## yarn (facebook + google)
### 1.x
+ 并行安装：同时处理多个包的下载和安装，大幅提升速度。
+ `yarn` 扁平化记录依赖，相较于 `npm` 的嵌套更优，且可以合并相同包相同范围声明的记录。
+ 引入标识符概念：`.lock` 文件直接记录唯一确定的包版本，与 `package.json` 中的范围声明区别开来。
```
扁平化和lock文件的方案都是 `yarn` 率先提出，`npm` 跟进。
```
+ 离线缓存：首次安装的包会被缓存到本地`（~/.yarn/cache）`，后续安装可直接复用，无需重复下载。
+ 安全校验：通过 `SHA-1` 哈希验证包完整性，防止恶意包篡改。

### 2.x
+ 引入 `Plug'n'Play（PnP）`模式：取消 `node_modules` 目录，拦截 `node.js` 对包的遍历； 通过全局缓存 + `.pnp.cjs` 文件映射包路径，通常被认为太激进了
+ 引入插件系统：允许通过插件扩展功能（如 @yarnpkg/plugin-typescript 支持 TypeScript 路径解析）。
+ *零安装（Zero-Installs）：将缓存的依赖包提交到 Git 仓库，新克隆项目可直接运行，无需 yarn install。* 会有一个`.gz` 文件被反复提交 `git`；感觉这个设计一般般 🥈
+ 更严格的依赖管理：默认禁止访问未在 `package.json` 中声明的依赖，避免隐式依赖问题。
> 幽灵依赖（隐式依赖），如项目声明依赖A包，A依赖B包，而项目没有直接声明B包；但因为`node_modules`中确实存在B包，项目代码中可以访问。有版本不可控的风险。
+ 工作区增强：支持 [monorepo](#monorepo) 项目，将路径映射的方案也应用到工作区中，实现跨包依赖管理。
  
### 3.x
+ 性能提升：PnP 模式的路径解析速度进一步优化，大型项目启动更快。
+ “混合模式”：可同时使用 `PnP` 和传统 `node_modules`。更好地兼容 `Webpack`、`Babel` 等工具链，减少 `PnP` 模式下的配置问题。*更像是一种妥协，如果实际使用混合模式可能有些奇怪*
+ `yarn dlx`临时下载并执行包对标 `npx`
+ 依赖约束：通过 `packageExtensions` 配置为第三方包补充缺失的依赖声明，解决幽灵依赖问题。*由于PnP模式彻底禁止访问幽灵依赖，这使得不规范的包难以使用，不利于推广*

### 4.x
+ 默认启用 `PnP`：强化零 `node_modules` 理念，但仍保留兼容模式选项。
+ 工作区协议优化：`workspace` 语法支持更灵活的跨包版本关联，简化 `monorepo` 内依赖管理。
+ 生态兼容性：对现代前端工具（如 Vite、Turbopack）的支持更完善，降低集成成本。

:::tip :face_with_head_bandage:探索者
想法很先进，映射文件的方案也很快，但是git提交缓存的方案个人觉得一般
:::


## pnpm 
与 `yarn` 不同，`pnpm` 项目诞生于一个npm 社区，然后通过全局存储和链接寻址的方案给出了当时全新的存储方案
:::tip 好家伙 🔨
这回真是智慧来源于劳动人民了
:::

### pnpm 10 
+ `pnpm` 核心存储方案：使用内容寻址存储 + 硬链接 + 符号链接的方式做指向
> 内容寻址是指`pnpm`的所有项目的所有包都放在全局，在项目中，`node_modules/.pnpm`使用硬链接的方式指向标识包。
> 至于符号链接，则是解决包之间的依赖关系，用来构建虚拟依赖树以兼容
+ `pnpm` 保留了虚拟 `node_modules`,对看源码更友好（符号链接的作用）
+ 而`yarn PnP`使用的是路径映射的方式
> 把缓存路径和依赖关系都写到`.pnp.cjs` 中，运行时使用`PnP加载器`拦截`NodeJs`的路径处理。*直接拦截并替换路径，理论性能更好——路径映射解析可能在特定场景下略慢于 pnpm 的链接机制。*
+ `yarn PnP` 部分工具需要用到 `yarn的插件` 做兼容。


## Monorepo {#monorepo} 
一种包管理策略，每一个公司级别的项目，其前端部分由多个不同的技术项目组成，比如：
:::info 场景 ⛰️
- 一个管理后台，管理字典和配置项 Admin
- 一个客户端应用，获取数据、实现业务 Client
:::
这种情况下，其核心业务通常会被多个项目共享。
:::tip :pencil2: 假设
我们定义了一个共享的项目core, 其中包含了核心业务逻辑、实体类定义、接口、权限等。来来看看传统方案和Monorepo的区别
:::

### git-submodule
这是一种传统策略，仅依赖git, 在主项目(Admin, Client)中，各自通过 `git submodule` 引入子项目`core`。
- 优点：简单、直接。
- 缺点：
  - 如果`core` 发生了改动，Admin项目和Client项目同步改动时，维护成本高。
  - 依赖版本混乱，可能出现 Admin的1.0.0 依赖 core的1.0.0，Admin的2.0.0 依赖 core的1.0.1 的情况。

###  Monorepo 方案
我们会将Admin, Client, core 三个项目放在一个仓库中，通过工作区的方式管理。
- 优点：
  - 依赖版本统一，不会出现版本混乱的情况。
  - `core` 发生更改时，其他项目的更改能在同一提交中被感知。叫原子化提交 (Atomic Commits)。
  - 项目之间的依赖关系可以直接在代码中声明，无需手动管理。
- 缺点：
  - 项目数量增加时，仓库体积会增加，维护成本会增加。

#### 核心配置 🔑
pnpm 为例，我们需要在根目录下的 `pnpm-workspace.yaml` 中配置工作区。
```text
my-app/
├── pnpm-workspace.yaml
├── package.json (根目录)
├── Admin/           # 管理后台应用
├── Client/          # 客户端应用
└── core/            # 共享逻辑包 (实体类、API、工具类)
```
pnpm-workspace.yaml
```yaml
packages:
  - 'Admin'
  - 'Client'
  - 'core'
```
安装工作区项目之间依赖
```bash
pnpm install @my-app/core --filter Admin Client
```
Admin/Client 项目的 package.json
```json
{
  "dependencies": {
    "@my-app/core": "workspace:*"
  }
}
```
使用 `@my-app/core` 包
```js
import { Entity } from '@my-app/core';
```

#### 依赖包的分类
| 配置               | 描述                                                                         |
| ------------------ | ---------------------------------------------------------------------------- |
| `dependencies`     | 运行时依赖，项目在运行时需要的包。各应用应该安装到自己的 `node_modules` 中。 |
| `devDependencies`  | 开发时依赖，项目在开发和构建时需要的包。如果配置统一，应该提升到工作区的 `node_modules` 中。 |
| `peerDependencies` | 同伴依赖，例如我在core中写了一个vue3的hooks, 这时候我知道使用`core`的项目一定会依赖vue3, 于是我定义成`peerDependencies`。`core` 不会直接安装vue3, 而是依赖项目自己安装vue3。                   |

### Monorepo 与微前端的关系
- Monorepo 更关注“复用”，项目之间的依赖关系。
- [微前端](./microFront.md)的目的是让不同的项目运行在一个应用上，如果项目之间的依赖关系不复杂，其实可以独立项目、独立仓库管理。不过既然已经考虑用微前端架构，那么项目之间的依赖关系基本上就会复杂起来，所以基本是搭配使用。

## MVVM 架构
MVVM 是一种前端架构模式，它将前端应用分为三个部分：
- Model：数据模型，负责处理数据的获取、存储和业务逻辑。
- View：用户界面，负责展示数据和与用户交互。
- ViewModel：连接 Model 和 View 的桥梁，负责处理业务逻辑和数据绑定。
:::tip 以Vue3 为例 🤔
- Vodel 包括接口、实体类、工具类等。在数据层面可以作为一个完整的应用。
- View 包括组件、模板、样式等。尽量脱离具体的业务逻辑，只关注展示数据和与用户交互。
- ViewModel 包括业务逻辑、数据绑定、事件处理等。
:::