# GIT & CI/CD
#### git 版本管理工具
本质作用是控制各类文件的多版本共存和协同开发。
#### CI（Continuous Integration）持续集成
代码一提交 → 自动拉代码 → 自动构建 → 自动测试 → 报告结果
#### CD（Continuous Delivery / Deployment）持续交付 / 部署
构建测试通过 → 自动部署到测试 / 预发 / 生产环境

## Git
虽然GIT（版本管理工具）和CI/CD是两个完全不同的概念，但CI/CD离不开git托管平台，所以把git提到了这里。

### git vs turtle :turtle:
turtle指的是SVN，但是当下git已经占据主流
下表来自AI 🤖
| 对比维度      | Git（分布式）                                                    | SVN（中心化/turtle）                                             |
| ------------- | ---------------------------------------------------------------- | ---------------------------------------------------------------- |
| **核心架构**  | 无严格「中央服务器」（可设一个作为协作中心），本地是完整仓库     | 必须有「中央服务器」，本地只是「工作副本」（无完整历史）         |
| **离线操作**  | 完全支持：离线可提交、创建分支、查看历史，联网后推送到服务器即可 | 几乎不能：提交、更新、看历史都必须连中央服务器                   |
| **版本号**    | 用「哈希值（SHA-1）」标识版本（如 `a8798d0`），是「内容寻址」    | 用「递增数字」标识版本（如 r1、r2、r3），是「增量计数」          |
| **分支/合并** | 分支是轻量级（本质是指针），创建/切换/合并极快，成本极低         | 分支是「复制整个目录」，创建/合并慢，成本高（多人协作易乱）      |
| **数据安全**  | 每个本地仓库都有完整历史，服务器挂了也能从任意本地仓库恢复       | 服务器是唯一数据中心，服务器崩了/数据丢了，历史记录就没了        |
| **提交逻辑**  | 先提交到「本地仓库」，再推送到远程（可批量推送）                 | 直接提交到「中央服务器」，一步到位（但必须联网）                 |
| **学习曲线**  | 稍陡（概念多：工作区、暂存区、本地库、远程库）                   | 更平缓（新手易理解：更新-修改-提交）                             |
| **适用场景**  | 大型项目、分布式团队、开源项目（如 Linux、Vue/React）            | 小型项目、集中式办公团队、对权限管控要求极细的场景（如传统企业） |

:::info 🤔
笔者除了实习的时候接触一个银行项目为了保密性，不愿意分布式仓库管理代码，强制使用SVN，其他项目都是使用git。当然也可能是权限管理（中心化的仓库可以单独对真实路径进行权限控制）和历史遗留原因。
:::

### git 分支模型
比较流行和通用的 git-flow 分支模型
- master 分支 \
永远保持稳定和可发布的状态。
每次发布一个新的版本时，都会从 develop 分支合并到 master 分支。

- develop 分支 \
用于集成所有的开发分支。
代表了最新的开发进度。
功能分支、发布分支和修复分支都从这里分支出去，最终合并回这里。

- feature 分支 \
用于开发新功能。
从 develop 分支创建，开发完成后合并回 develop 分支。
命名规范：feature/feature-name。

- release 分支 \
用于准备新版本的发布。
从 develop 分支创建，进行最后的测试和修复，然后合并回 develop 和 master 分支，并打上版本标签。
命名规范：release/release-name。

- hotfix 分支 \
用于修复紧急问题。
从 master 分支创建，修复完成后合并回 master 和 develop 分支，并打上版本标签。
命名规范：hotfix/hotfix-name。

### git 托管平台
于svn不同，由于git是分布式的，所有本地的代码其实都是一个完整的仓库。而团队协作则靠托管平台完成，开发者通过remote的name和url进行关联，比如默认的`origin`；
- GitHub（微软收购），主流，公开项目免费云服务，公司不会首选
- GitLab：涉及涉密，后由中国极狐代理大陆等市场
- Bitbucket：成套方案。之前呆过一家公司用的 jira(任务管理类似阿里的 Teambition) + bitbucket 作为代码托管平台

## CI/CD
git托管平台有自己的CI/CD服务，其核心是自动构建、测试和部署。配置文件 `.yml/.groovy` 存在一定差异。
### Jenkins 为例
核心插件：**Pipeline**
:::details 简单的 Jenkinsfile 示例
```groovy
pipeline {
    // 运行节点（填你的 Jenkins 节点名称，默认填 'any' 即可）
    agent any

    // 配置 Node.js 环境（名称要和全局工具配置中 Node.js 22 的名称一致）
    tools {
        nodejs 'NodeJS 22' // 关键：此处名称需和全局配置的 Node.js 22 名称完全匹配
    }

    // 构建步骤
    stages {
        stage('安装 pnpm 并配置') {
            steps {
                script {
                    // 1. 全局安装 pnpm（Node.js 22 已自带 npm，直接用 npm 装）
                    sh 'npm install -g pnpm'
                    // 2. 验证 pnpm 版本（可选，用于排查问题）
                    sh 'pnpm -v'
                }
            }
        }

        stage('安装依赖') {
            steps {
                script {
                    // 使用 pnpm 安装依赖，--frozen-lockfile 强制使用锁文件（保证版本一致）
                    sh 'pnpm install --frozen-lockfile'
                }
            }
            // 缓存依赖（关键：下次构建无需重复下载，大幅提速）
            post {
                always {
                    cache(path: 'node_modules', key: "pnpm-${checksum 'pnpm-lock.yaml'}", restoreKeys: ['pnpm-'])
                }
            }
        }

        stage('执行构建') {
            steps {
                script {
                    // 执行 pnpm build（和本地命令一致）
                    sh 'pnpm run build'
                }
            }
        }
    }

    // 构建后操作（可选：打印构建结果）
    post {
        success {
            echo '✅ 构建成功！'
        }
        failure {
            echo '❌ 构建失败，请检查日志！'
        }
    }
}
```
:::

:::tip 关注构建流程 👀
- 跳过初始化：可以全局配置必要的插件和环境（如 Node.js、pnpm），避免每次构建都重复安装。
- 缓存依赖：可以配置全局缓存依赖，避免每次构建都重复下载依赖。
- 针对项目的流程：可以根据项目的具体需求，定制化构建流程。
:::

## 自动化测试
TODO: 还需学习
